[{"authors":["Brian Wickman","Hong Hu","Insu Yun","Daehee Jang","JungWon Lim","Sanidhya Kashyap","Taesoo Kim"],"categories":[],"content":"","date":1627776000,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1605927634,"objectID":"e5a4daf0be1274bec71d1ce6564c04b7","permalink":"https://kaist-s4.github.io/publication/wickman-ffmalloc/","publishdate":"2020-11-21T07:51:46.556422Z","relpermalink":"/publication/wickman-ffmalloc/","section":"publication","summary":"","tags":[],"title":"Preventing Use-After-Free Attacks with Fast Forward Allocation (to appear)","type":"publication"},{"authors":["Insu Yun","Dhaval Kapil","Taesoo Kim"],"categories":[],"content":"","date":1596240000,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1605927634,"objectID":"ea8cb68cf4bf59c0580bce923e050c53","permalink":"https://kaist-s4.github.io/publication/yun-archeap/","publishdate":"2020-11-21T07:51:46.805847Z","relpermalink":"/publication/yun-archeap/","section":"publication","summary":"Exploitation techniques to abuse metadata of heap allocators have been widely studied because of their generality (i.e., application independence) and powerfulness (i.e., bypassing modern mitigation). However, such techniques are commonly considered arts, and thus the ways to discover them remain ad-hoc, manual, and allocator-specific.\n\nIn this paper, we present an automatic tool, ArcHeap, to systematically discover the unexplored heap exploitation primitives, regardless of their underlying implementations. The key idea of ArcHeap is to let the computer autonomously explore the spaces, similar in concept to fuzzing, by specifying a set of common designs of modern heap allocators and root causes of vulnerabilities as models, and by providing heap operations and attack capabilities as actions. During the exploration, ArcHeap checks whether the combinations of these actions can be potentially used to construct exploitation primitives, such as arbitrary write or overlapped chunks. As a proof, ArcHeap generates working PoC that demonstrates the discovered exploitation technique.\n\nWe evaluated ArcHeap with ptmalloc2 and 10 other allocators, and discovered five previously unknown exploitation techniques in ptmalloc2 as well as several techniques against seven out of 10 allocators including the security-focused allocator, DieHarder. To show the effectiveness of ArcHeap's approach in other domains, we also studied how security features and exploit primitives evolve across different versions of ptmalloc2.\n","tags":[],"title":"Automatic Techniques to Systematically Discover New Heap Exploitation Primitives","type":"publication"},{"authors":["Yonghwi Jin","Jungwon Lim","Insu Yun","Taesoo Kim"],"categories":[],"content":"","date":1596240000,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1605927634,"objectID":"5d5f2c21ae76a5e24b82451a8b3db3b5","permalink":"https://kaist-s4.github.io/publication/jin-pwn-2-own-2020-safari/","publishdate":"2020-11-21T07:51:46.973052Z","relpermalink":"/publication/jin-pwn-2-own-2020-safari/","section":"publication","summary":"Compromising a kernel through a browser is the ultimate goal for offensive security researchers. Because of continuous efforts to eliminate vulnerabilities and introduce various mitigations, a remote kernel exploit from a browser becomes extremely difficult, seemingly impossible.\n\nIn this talk, we will share our Safari exploit submitted to Pwn2Own 2020. Combining *SIX* different vulnerabilities, our exploit successfully compromises the macOS kernel starting from the Safari browser. It breaks every mitigation in macOS including ASLR, DEP, sandbox, and even System Integrity Protection (SIP). Inspecting every vulnerability used in this exploit, we will show not only state-of-the-art hacking techniques but also challenges in protecting complicated systems (i.e., browsers and operating systems) and in introducing their mitigations. Moreover, we will introduce a new technique that reliably exploits a TOCTOU vulnerability in macOS.\n\n","tags":[],"title":"Compromising the macOS kernel through Safari by chaining six vulnerabilities","type":"publication"},{"authors":["Soyeon Park","Wen Xu","Insu Yun","Daehee Jang","Taesoo Kim"],"categories":[],"content":"","date":1588291200,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1605927634,"objectID":"d5f355ce1e74a693994f2b8f3dc7a734","permalink":"https://kaist-s4.github.io/publication/park-die/","publishdate":"2020-11-21T07:51:47.147149Z","relpermalink":"/publication/park-die/","section":"publication","summary":"Fuzzing is a practical, widely-deployed technique to find bugs in complex, real-world programs like JavaScript engines. We observed, however, that existing fuzzing approaches, either generative or mutational, fall short in fully harvesting high-quality input corpora such as known proof of concept (PoC) exploits or unit tests. Existing fuzzers tend to destruct subtle semantics or conditions encoded in the input corpus in order to generate new test cases because this approach helps in discovering new code paths of the program. Nevertheless, for JavaScript-like complex programs, such a conventional design leads to test cases that tackle only shallow parts of the complex codebase and fails to reach deep bugs effectively due to the huge input space.\n\nIn this paper, we advocate a new technique, called an aspect-preserving mutation, that stochastically preserves the desirable properties, called aspects, that we prefer to be maintained across mutation. We demonstrate the aspect preservation with two mutation strategies, namely, structure and type preservation, in our fully-fledged JavaScript fuzzer, called DIE. Our evaluation shows that DIE's aspect-preserving mutation is more effective in discovering new bugs (5.7 x more unique crashes) and producing valid test cases (2.4 x fewer runtime errors) than the state-of-the-art JavaScript fuzzers. DIE newly discovered 48 high-impact bugs in ChakraCore, JavaScriptCore, and V8 (38 fixed with 12 CVEs assigned as of today). The source code of DIE is publicly available as an open-source project.\n","tags":[],"title":"Fuzzing JavaScript Engines with Aspect-preserving Mutation","type":"publication"},{"authors":["Weidong Cui","Xinyang Ge","Baris Kasikci","Ben Niu","Upamanyu Sharma","Ruoyu Wang","Insu Yun"],"categories":[],"content":"","date":1538352000,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1605927635,"objectID":"6d57b4669ac9b8bb6de553e5361eb28c","permalink":"https://kaist-s4.github.io/publication/cui-rept/","publishdate":"2020-11-21T07:51:47.388526Z","relpermalink":"/publication/cui-rept/","section":"publication","summary":"Debugging software failures in deployed systems is important because they\nimpact real users and customers. However, debugging such failures is\nnotoriously hard in practice because developers have to rely on limited\ninformation such as memory dumps. The execution history is usually unavailable\nbecause high-fidelity program tracing is not affordable in deployed systems.\n\nIn this paper, we present REPT, a practical system that enables reverse\ndebugging of software failures in deployed systems. REPT reconstructs the\nexecution history with high fidelity by combining online lightweight hardware\ntracing of a program's control flow with offline binary analysis that recovers\nits data flow. It is seemingly impossible to recover data values thousands of\ninstructions before the failure due to information loss and concurrent\nexecution. REPT tackles these challenges by constructing a partial execution\norder based on timestamps logged by hardware and iteratively performing forward\nand backward execution with error correction.\n\nWe design and implement REPT, deploy it on Microsoft Windows, and integrate it\ninto Windows Debugger. We evaluate REPT on 16 real-world bugs and show that it\ncan recover data values accurately (92% on average) and efficiently (less than\n20 seconds) for these bugs. We also show that it enables effective reverse\ndebugging for 14 bugs.\n","tags":[],"title":"REPT: Reverse Debugging of Failures in Deployed Software","type":"publication"},{"authors":["Insu Yun","Sangho Lee","Meng Xu","Yeongjin Jang","Taesoo Kim"],"categories":[],"content":"","date":1533081600,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1605927635,"objectID":"eb5181f52b2a536fba3b5247c74d69b1","permalink":"https://kaist-s4.github.io/publication/yun-qsym/","publishdate":"2020-11-21T07:51:47.756236Z","relpermalink":"/publication/yun-qsym/","section":"publication","summary":"Recently, hybrid fuzzing has been proposed to address the limitations of\nfuzzing and concolic execution by combining both approaches. The hybrid\napproach has shown its effectiveness in various synthetic benchmarks such as\nDARPA Cyber Grand Challenge (CGC) binaries, but it still suffers from scaling\nto find bugs in complex, real-world software. We observed that the performance\nbottleneck of the existing concolic executor is the main limiting factor for\nits adoption beyond a small-scale study.\n\nTo overcome this problem, we design a fast concolic execution engine, called\nQSYM, to support hybrid fuzzing. The key idea is to tightly integrate the\nsymbolic emulation with the native execution using dynamic binary translation,\nmaking it possible to implement more fine-grained, so faster, instruction-level\nsymbolic emulation. Additionally, QSYM loosens the strict soundness\nrequirements of conventional concolic executors for better performance, yet\ntakes advantage of a faster fuzzer for validation, providing unprecedented\nopportunities for performance optimizations, e.g., optimistically solving\nconstraints and pruning uninteresting basic blocks.\n\nOur evaluation shows that QSYM does not just outperform state-of-the-art\nfuzzers (i.e., found 14Ã— more bugs than VUzzer in the LAVA-M dataset, and\noutperformed Driller in 104 binaries out of 126), but also found 13 previously\nunknown security bugs in eight real-world programs like Dropbox Lepton, ffmpeg,\nand OpenJPEG, which have already been intensively tested by the\nstate-of-the-art fuzzers, AFL and OSS-Fuzz.\n","tags":[],"title":"QSYM: A Practical Concolic Execution Engine Tailored for Hybrid Fuzzing","type":"publication"},{"authors":["Jinho Jung","Chanil Jeon","Max Wolotsky","Insu Yun","Taesoo Kim"],"categories":[],"content":"","date":1498867200,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1605927635,"objectID":"5d65636ac64d46bf505e232f1921811b","permalink":"https://kaist-s4.github.io/publication/jung-avpass/","publishdate":"2020-11-21T07:51:48.100293Z","relpermalink":"/publication/jung-avpass/","section":"publication","summary":"AVPASS is a tool for leaking the detection model \nof Android antivirus (AV) programs, and bypassing \nthe AV detection by using the leaked information \ncoupled with APK perturbation techniques. AVPASS \nis able to infer not only the detection features, \nbut also hierarchy of detection rule chains. \nWith help from the leaked model and the built-in \nAPK perturbation functions, AVPASS is able to \ndisguise any android malware as a benign application. \nFurthermore, using our novel additive mode, AVPASS \nsupports safe querying and guarantees that one can \ntest if the application will be detected by the AV \nwithout sending the whole or core parts of application. \nAs a result, AVPASS leaked significant detection \nfeatures of commercial AVs and achieved almost \nzero detection from VirusTotal when tested with \nmore than 5,000 malware. \n\nIn this talk, we present the entire pipeline of \nthe APK perturbation process, leaking model process, \nand auto-bypassing process. In addition, we show \nfindings about commercial AVs, including their \ndetection features and hierarchy, and inform the \nattendees about the potential weaknesses of modern AVs. \n\nAVPASS will be demonstrated, showing that it modifies \nreal world malware precisely, and allows them to \nbypass all AVs following the leaked model. AVPASS \nwill be released with every tool that we have built, \nincluding the original source code and the related \ntest data, to enable researchers to replicate the \nresearch on their own.\n\n","tags":[],"title":"AVPASS: Leaking and Bypassing Antivirus Detection Model Automatically","type":"publication"},{"authors":["Su Yong Kim","Sangho Lee","Insu Yun","Wen Xu","Byoungyoung Lee","Youngtae Yun","Taesoo Kim"],"categories":[],"content":"","date":1498867200,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1605927635,"objectID":"071f0e16b1742a1a73d3981dd070583b","permalink":"https://kaist-s4.github.io/publication/kim-cab-fuzz/","publishdate":"2020-11-21T07:51:48.437036Z","relpermalink":"/publication/kim-cab-fuzz/","section":"publication","summary":"Discovering the security vulnerabilities of commercial off-the-shelf\n(COTS) operating systems (OSes) is challenging because they not only\nare huge and complex, but also lack detailed debug\ninformation. Concolic testing, which generates all feasible inputs of\na program by using symbolic execution and tests the program with the\ngenerated inputs, is one of the most promising approaches to solve\nthis problem. Unfortunately, the state-of-the-art concolic testing\ntools do not scale well for testing COTS OSes because of state\nexplosion. Indeed, they often fail to find a single bug (or crash) in\nCOTS OSes despite their long execution time.\n\nIn this paper, we propose CAB-Fuzz (Context-Aware and\nBoundary-focused), a practical concolic testing tool to quickly\nexplore interesting paths that are highly likely triggering real bugs\nwithout debug information. First, CAB-Fuzz prioritizes the boundary\nstates of arrays and loops, inspired by the fact that many\nvulnerabilities originate from a lack of proper boundary\nchecks. Second, CAB-Fuzz exploits real programs interacting with COTS\nOSes to construct proper contexts to explore deep and complex kernel\nstates without debug information. We applied CAB-Fuzz to Windows 7 and\nWindows Server 2008 and found 21 undisclosed unique crashes, including\ntwo local privilege escalation vulnerabilities (CVE2015-6098 and\nCVE-2016-0040) and one information disclosure vulnerability in a\ncryptography driver (CVE2016-7219). CAB-Fuzz found vulnerabilities\nthat are non-trivial to discover; five vulnerabilities have existed\nfor 14 years, and we could trigger them even in the initial version of\nWindows XP (August 2001).","tags":[],"title":"CAB-Fuzz: Practical Concolic Testing Techniques for COTS Operating Systems","type":"publication"},{"authors":["Insu Yun","Changwoo Min","Xujie Si","Yeongjin Jang","Taesoo Kim","Mayur Naik"],"categories":[],"content":"","date":1470009600,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1605927635,"objectID":"f0a607f7b4f7d3016efd7822ea90ff21","permalink":"https://kaist-s4.github.io/publication/yun-apisan/","publishdate":"2020-11-21T07:51:48.800786Z","relpermalink":"/publication/yun-apisan/","section":"publication","summary":"API misuse is a well-known source of bugs. Some of them (e.g., incorrect use of\nSSL API, and integer overflow of memory allocation size) can cause serious\nsecurity vulnerabilities (e.g., man-in-the-middle (MITM) attack, and privilege\nescalation). Moreover, modern APIs, which are large, complex, and fast\nevolving, are error-prone. However, existing techniques to help finding bugs\nrequire manual effort by developers (e.g., providing specification or model) or\nare not scalable to large real-world software comprising millions of lines of\ncode.\n\nIn this paper, we present APISAN, a tool that automatically infers correct API\nusages from source code without manual effort. The key idea in APISAN is to\nextract likely correct usage patterns in four different aspects (e.g., causal\nrelation, and semantic relation on arguments) by considering semantic\nconstraints. APISAN is tailored to check various properties with security\nimplications. We applied APISAN to 92 million lines of code, including Linux\nKernel, and OpenSSL, found 76 previously unknown bugs, and provided patches for\nall the bugs.\n","tags":[],"title":"APISan: Sanitizing API Usages through Semantic Cross-checking","type":"publication"},{"authors":["Chengyu Song","Hyungon Moon","Monjur Alam","Insu Yun","Byoungyoung Lee","Taesoo Kim","Wenke Lee","Yunheung Paek"],"categories":[],"content":"","date":1462060800,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1605927636,"objectID":"43a9d55ee3fcd955c2852af8602c367b","permalink":"https://kaist-s4.github.io/publication/song-hdfi/","publishdate":"2020-11-21T07:51:49.155583Z","relpermalink":"/publication/song-hdfi/","section":"publication","summary":"Memory corruption vulnerabilities are the root cause of many modern attacks. Existing defense mechanisms are inadequate; in general, the software-based approaches are not efficient and the hardware-based approaches are not flexible. In this paper, we present hardware-assisted data-flow isolation, or, Hdfi, a new fine-grained data isolation mechanism that is broadly applicable and very efficient. Hdfi enforces isolation at the machine word granularity by virtually extending each memory unit with an additional tag that is defined by data-flow. This capability allows Hdfi to enforce a variety of security models such as the Biba Integrity Model and the Bell--LaPadula Model. We implemented Hdfi by extending the RISC-V instruction set architecture (ISA) and instantiating it on the Xilinx Zynq ZC706 evaluation board. We ran several benchmarks including the SPEC CINT 2000 benchmark suite. Evaluation results show that the performance overhead caused by our modification to the hardware is low (","tags":[],"title":"HDFI: Hardware-Assisted Data-Fow Isolation","type":"publication"},{"authors":["Shinjo Park","Suwan Park","Insu Yun","Dongkwan Kim","Yongdae Kim"],"categories":[],"content":"","date":1406851200,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1605927636,"objectID":"bdb710bfcd69afef03045dfbb77a815c","permalink":"https://kaist-s4.github.io/publication/park-pki/","publishdate":"2020-11-21T07:51:49.422855Z","relpermalink":"/publication/park-pki/","section":"publication","summary":"","tags":[],"title":"Analyzing Security of Korean USIM-based PKI Certificate Service","type":"publication"},{"authors":["Muhammad Jamshed","Jihyung Lee","Sangwoo Moon","Insu Yun","Deokjin Kim","Sungryoul Lee","Yung Yi","KyoungSoo Park"],"categories":[],"content":"","date":1349049600,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1605927636,"objectID":"d00a8a94be1b3114b7c34a37c5c721f6","permalink":"https://kaist-s4.github.io/publication/jamshed-kargus/","publishdate":"2020-11-21T07:51:49.681831Z","relpermalink":"/publication/jamshed-kargus/","section":"publication","summary":"","tags":[],"title":"Kargus: A Highly-scalable Software-based Intrusion Detection System","type":"publication"},{"authors":null,"categories":null,"content":"","date":-62135596800,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":-62135596800,"objectID":"c1d17ff2b20dca0ad6653a3161942b64","permalink":"https://kaist-s4.github.io/people/","publishdate":"0001-01-01T00:00:00Z","relpermalink":"/people/","section":"","summary":"","tags":null,"title":"","type":"widget_page"},{"authors":null,"categories":null,"content":"","date":-62135596800,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":-62135596800,"objectID":"f7b88632088813b96a8858fe6d849ca6","permalink":"https://kaist-s4.github.io/author/insu-yun/","publishdate":"0001-01-01T00:00:00Z","relpermalink":"/author/insu-yun/","section":"authors","summary":"","tags":null,"title":"Insu Yun","type":"authors"}]